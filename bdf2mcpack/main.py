import zipfile
import json

from argparse import ArgumentParser
from bdfparser import Font, Glyph, Bitmap
from io import TextIOWrapper
from zipfile import ZipFile
from PIL import Image

DEFAULT_OUTPUT_FILENAME = "pack.zip"

DEFAULT_PACK_FORMAT = 18

DEFAULT_DESCRIPTION = "Generated by bdf2mcpack"

DEFAULT_COMPRESS_LEVEL = 6

def main():
    argument_parser = ArgumentParser(description="Creates a resource pack for Minecraft from a BDF type file.")
    argument_parser.add_argument("input", help="The filename of the BDF file to load")
    argument_parser.add_argument("-o", default=DEFAULT_OUTPUT_FILENAME, metavar="output",
                                 help=f"The Filename of the resource pack to create (default: {DEFAULT_OUTPUT_FILENAME})")
    argument_parser.add_argument("--format", "-f", default=DEFAULT_PACK_FORMAT, type=int,
                                 help=f"The value to set as pack.pack_format in pack.mcmeta (default: {DEFAULT_PACK_FORMAT})")
    argument_parser.add_argument("--description", "-d", default=DEFAULT_DESCRIPTION,
                                 help=f"The text to set as pack.description in pack.mcmeta (default: \"{DEFAULT_DESCRIPTION}\")")
    argument_parser.add_argument("--compresslevel", "-c", default=DEFAULT_COMPRESS_LEVEL, choices=range(0, 9 + 1),
                                 help=f"The compression level used when writing the output file (default: {DEFAULT_COMPRESS_LEVEL})")
    args=argument_parser.parse_args()
    convert(args.input, output_filename=args.o, pack_format=args.format, description=args.description, compresslevel=args.compresslevel)

def convert(input_filename: str, output_filename: str, pack_format: int, description: str, compresslevel: int):
    with ResourcePack(output_filename, compresslevel=compresslevel) as output:
        output.write_pack_mcmeta(pack_format, description)
        font = Font(input_filename)
        providers = list()
        for glyph in font.iterglyphs():
            bitmap = glyph.draw()
            providers.append(create_provider(glyph, bitmap))
            output.write_glyph_bitmap(glyph, bitmap)
        output.write_providers(providers)

class ResourcePack(ZipFile):
    def __init__(self, file: str, compresslevel: int):
        super().__init__(file, "w", compression=zipfile.ZIP_DEFLATED, compresslevel=compresslevel)

    def write_json(self, filename: str, json_object: dict):
        with self.open(filename, "w") as json_file:
            json.dump(json_object, TextIOWrapper(json_file, "utf-8"))

    def write_pack_mcmeta(self, pack_format: int, description: str):
        self.write_json("pack.mcmeta", {
            "pack": {
                "pack_format": pack_format,
                "description": description
            }
        })

    def write_providers(self, providers: list[dict]):
        self.write_json("assets/minecraft/font/default.json", {
            "providers": providers
        })

    def write_glyph_bitmap(self, glyph: Glyph, bitmap: Bitmap):
        filename = "assets/minecraft/textures/" + glyph_filename(glyph)
        self.write_image(filename, bitmap_to_image(bitmap))

    def write_image(self, filename: str, image: Image):
        with self.open(filename, "w") as file:
            image.save(file, "PNG")

def glyph_filename(glyph: Glyph):
    return f"font/{glyph.cp():06x}.png"

def create_provider(glyph: Glyph, bitmap: Bitmap):
    HEIGHT = 8
    bitmap_height = bitmap.height()
    return {
        "type": "bitmap",
        "file": "minecraft:" + glyph_filename(glyph),
        "height": HEIGHT,
        "ascent": round((bitmap_height - glyph.origin()[1]) * HEIGHT / bitmap_height),
        "chars": [glyph.chr()]
    }

def bitmap_to_image(bitmap: Bitmap):
    width = bitmap.width()
    height = bitmap.height()
    result = Image.frombytes("RGBA", (width, height), bitmap.tobytes("RGBA"))
    for y in range(height):
        for x in range(width):
            xy = (x, y)
            _, _, _, alpha = result.getpixel(xy)
            if alpha != 0:
                result.putpixel(xy, (0xff, 0xff, 0xff, 0xff))
    return result
