import zipfile
import json

from argparse import ArgumentParser
from bdfparser import Font, Glyph, Bitmap
from io import TextIOWrapper
from zipfile import ZipFile
from PIL import Image

DEFAULT_OUTPUT_FILENAME = "pack.zip"

DEFAULT_PACK_FORMAT = 18

DEFAULT_DESCRIPTION = "Generated by bdf2mcpack"

DEFAULT_COMPRESS_LEVEL = 6

def main():
    argument_parser = ArgumentParser(description="Creates a resource pack for Minecraft from a BDF type file.")
    argument_parser.add_argument("input", help="The filename of the BDF file to load")
    argument_parser.add_argument("-o", default=DEFAULT_OUTPUT_FILENAME, metavar="output",
                                 help=f"The Filename of the resource pack to create (default: {DEFAULT_OUTPUT_FILENAME})")
    argument_parser.add_argument("--format", "-f", default=DEFAULT_PACK_FORMAT, type=int,
                                 help=f"The value to set as pack.pack_format in pack.mcmeta (default: {DEFAULT_PACK_FORMAT})")
    argument_parser.add_argument("--description", "-d", default=DEFAULT_DESCRIPTION,
                                 help=f"The text to set as pack.description in pack.mcmeta (default: \"{DEFAULT_DESCRIPTION}\")")
    argument_parser.add_argument("--compresslevel", "-c", default=DEFAULT_COMPRESS_LEVEL, choices=range(0, 9 + 1),
                                 help=f"The compression level used when writing the output file (default: {DEFAULT_COMPRESS_LEVEL})")
    args=argument_parser.parse_args()
    convert(args.input, output_filename=args.o, pack_format=args.format, description=args.description, compresslevel=args.compresslevel)

def convert(input_filename: str, output_filename: str, pack_format: int, description: str, compresslevel: int):
    with ZipFile(output_filename, "w", compression=zipfile.ZIP_DEFLATED, compresslevel=compresslevel) as output:
        write_pack_mcmeta(output, pack_format, description)
        font = Font(input_filename)
        providers = list()
        for glyph in font.iterglyphs():
            bitmap = glyph.draw()
            providers.append(create_provider(glyph, bitmap))
            write_glyph_bitmap(output, glyph, bitmap)
        write_providers(output, providers)

def write_json(output: ZipFile, filename: str, json_object: dict):
    with output.open(filename, "w") as json_file:
        json.dump(json_object, TextIOWrapper(json_file, "utf-8"))

def write_pack_mcmeta(output: ZipFile, pack_format: int, description: str):
    write_json(output, "pack.mcmeta", {
        "pack": {
            "pack_format": pack_format,
            "description": description
        }
    })

def glyph_filename(glyph: Glyph):
    return f"font/{glyph.cp():06x}.png"

def create_provider(glyph: Glyph, bitmap: Bitmap):
    HEIGHT = 8
    bitmap_height = bitmap.height()
    return {
        "type": "bitmap",
        "file": "minecraft:" + glyph_filename(glyph),
        "height": HEIGHT,
        "ascent": (bitmap_height - glyph.origin()[1]) * HEIGHT // bitmap_height,
        "chars": [glyph.chr()]
    }

def write_providers(output: ZipFile, providers: list[dict]):
    write_json(output, "assets/minecraft/font/default.json", {
        "providers": providers
    })

def write_glyph_bitmap(output: ZipFile, glyph: Glyph, bitmap: Bitmap):
    filename = "assets/minecraft/textures/" + glyph_filename(glyph)
    write_image(output, filename, bitmap_to_image(bitmap))

def write_image(output: ZipFile, filename: str, image: Image):
    with output.open(filename, "w") as file:
        image.save(file, "PNG")

def bitmap_to_image(bitmap: Bitmap):
    width = bitmap.width()
    height = bitmap.height()
    result = Image.frombytes("RGBA", (width, height), bitmap.tobytes("RGBA"))
    for y in range(height):
        for x in range(width):
            xy = (x, y)
            _, _, _, alpha = result.getpixel(xy)
            if alpha != 0:
                result.putpixel(xy, (0xff, 0xff, 0xff, 0xff))
    return result
