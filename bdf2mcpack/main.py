import zipfile
import json
import itertools
import re

from argparse import ArgumentParser
from dataclasses import dataclass
from bdfparser import Font, Glyph
from io import TextIOWrapper
from zipfile import ZipFile
from PIL import Image
from tqdm import tqdm

DEFAULT_OUTPUT_FILENAME = "pack.zip"

DEFAULT_PACK_FORMAT = 18

DEFAULT_DESCRIPTION = "Generated by bdf2mcpack"

DEFAULT_COMPRESS_LEVEL = 6

COLOR_TRANSPARENT = (0x00, 0x00, 0x00, 0x00)

COLOR_BACKGROUND = (0xff, 0xff, 0xff, 0x0d)  # 5% opaque

COLOR_FOREGROUND = (0xff, 0xff, 0xff, 0xff)

RE_CODEPOINT_DOUBLE = re.compile(
        r"^(\d+|[Uu]\+(?:[\dA-Fa-f]{4,6}))-(\d+|[Uu]\+(?:[\dA-Fa-f]{4,6}))$")


def main():
    argument_parser = ArgumentParser(
            description="Creates a resource pack for Minecraft"
            "from a BDF type file.")
    argument_parser.add_argument(
            "input", help="The filename of the BDF file to load")
    argument_parser.add_argument(
            "-o", default=DEFAULT_OUTPUT_FILENAME,
            metavar="output",
            help=f"The Filename of the resource pack to create"
                 f" (default: {DEFAULT_OUTPUT_FILENAME})")
    argument_parser.add_argument(
            "--format", "-f", default=DEFAULT_PACK_FORMAT, type=int,
            help=f"The value to set as pack.pack_format in pack.mcmeta"
                 f" (default: {DEFAULT_PACK_FORMAT})")
    argument_parser.add_argument(
            "--description", "-d", default=DEFAULT_DESCRIPTION,
            help=f"The text to set as pack.description in pack.mcmeta"
                 f" (default: \"{DEFAULT_DESCRIPTION}\")")
    argument_parser.add_argument(
            "--compresslevel", "-c", default=DEFAULT_COMPRESS_LEVEL,
            choices=range(0, 9 + 1),
            help=f"The compression level used when writing the output file"
                 f" (default: {DEFAULT_COMPRESS_LEVEL})")
    argument_parser.add_argument(
            "--range", "-r", nargs="*", type=codepoint_double,
            help="The Unicode codepoint range to use. "
                 "Accepts decimal or hexadecimal expressions of codepoints. "
                 "Case insensitive. "
                 "e.g. 0-127 U+100000-U+10FFFF")
    args = argument_parser.parse_args()
    convert(args.input, output_filename=args.o, pack_format=args.format,
            description=args.description, compresslevel=args.compresslevel,
            range=args.range)


def codepoint_double(expr: str):
    match_result = RE_CODEPOINT_DOUBLE.match(expr)
    if not match_result:
        raise ValueError(
                f"Cannot parse \"{expr}\"; the expression need to match"
                f"regular expression {RE_CODEPOINT_DOUBLE}")
    start_str = match_result.group(1)
    end_str = match_result.group(2)
    return (parse_codepoint(start_str), parse_codepoint(end_str))


def parse_codepoint(expr: str):
    first_char = expr[0]
    if first_char == "U" or first_char == "u":
        return int(expr[2:], base=16)  # parses the hex part
    else:
        return int(expr)


def convert(input_filename: str, output_filename: str, pack_format: int,
            description: str, compresslevel: int, range):
    with ResourcePack(output_filename, compresslevel=compresslevel) as output:
        output.write_pack_mcmeta(pack_format, description)
        font = Font(input_filename)
        output.write_font_info(font)
        glyphs = list(font.iterglyphs(r=range))
        for glyph in tqdm(glyphs, desc="Create glyph images"):
            output.add_glyph(ProviderGlyph(glyph))
        output.flush()


@dataclass(frozen=True)
class ProviderType:
    height: int
    ascent: int
    bitmap_size: (int, int)

    def base_name(self, classifier):
        return (f"h{self.height:02}a{self.ascent:02}"
                f"_{self.bitmap_size[0]:02}x{self.bitmap_size[1]:02}"
                f"_{classifier:02}")


class ProviderGlyph:
    __HEIGHT = 8

    def __init__(self, glyph: Glyph):
        bitmap = glyph.draw()
        height = ProviderGlyph.__HEIGHT
        ascent = round(height * (1 - glyph.origin()[1] / bitmap.height()))
        size = (bitmap.width(), bitmap.height())
        self.__glyph = glyph
        self.__bitmap = bitmap
        self.__provider_type = ProviderType(height, ascent, size)

    def provider_type(self):
        return self.__provider_type

    def glyph(self):
        return self.__glyph

    def glyph_filename(self):
        return f"font/{self.__glyph.cp():06x}.png"

    def to_image(self):
        width = self.__bitmap.width()
        height = self.__bitmap.height()
        result = Image.frombytes(
                "RGBA", (width, height), self.__bitmap.tobytes("RGBA"))
        for y in range(height):
            for x in range(width):
                xy = (x, y)
                _, _, _, alpha = result.getpixel(xy)
                if alpha != 0:
                    result.putpixel(xy, COLOR_FOREGROUND)
                else:
                    result.putpixel(xy, COLOR_BACKGROUND)
        return result


class Provider:
    __HORIZONTAL_GLYPH_MAX = 16

    __VERTICAL_PIXEL_MAX = 4096

    def __init__(self, provider_type: ProviderType, classifier: int):
        self.__provider_type = provider_type
        _, bitmap_height = provider_type.bitmap_size
        vertical_glyph_max = Provider.__VERTICAL_PIXEL_MAX // bitmap_height
        self.__glyph_max = vertical_glyph_max * Provider.__HORIZONTAL_GLYPH_MAX
        self.__glyphs: list[ProviderGlyph] = list()
        self.__classifier = classifier
        self.__locked = False

    def appendable(self):
        return (not self.__locked) and (len(self.__glyphs) < self.__glyph_max)

    def append_glyph(self, provider_glyph: ProviderGlyph):
        if (not self.appendable()) or \
           (provider_glyph.provider_type() != self.__provider_type):
            raise ValueError()
        self.__glyphs.append(provider_glyph)

    def lock(self):
        self.__locked = True

    def json_object(self):
        self.lock()
        chars: list[str] = list()
        for i, c in enumerate(
                map(lambda glyph: glyph.glyph().chr(), self.__glyphs)):
            if (i % Provider.__HORIZONTAL_GLYPH_MAX == 0):
                chars.append(c)
            else:
                chars[-1] = chars[-1] + c
        if chars:  # if chars is not empty
            chars[-1] = chars[-1].ljust(
                    self.horizontal_glyph_count(), "\u0000")
        return {
            "type": "bitmap",
            "file": "minecraft:" + self.filename(),
            "height": self.__provider_type.height,
            "ascent": self.__provider_type.ascent,
            "chars": chars
        }

    def image(self):
        self.lock()
        glyph_count = len(self.__glyphs)
        if glyph_count == 0:
            return None
        glyph_width, glyph_height = self.__provider_type.bitmap_size
        horizontal_glyph_count = self.horizontal_glyph_count()
        vertial_glyph_count = div_round_up(
                glyph_count, Provider.__HORIZONTAL_GLYPH_MAX)
        image_width = glyph_width * horizontal_glyph_count
        image_height = glyph_height * vertial_glyph_count
        result = Image.new(
                "RGBA", (image_width, image_height), COLOR_TRANSPARENT)
        desc = f"Create {self.filename()}"
        for i, image in tqdm(
                enumerate(map(lambda glyph: glyph.to_image(), self.__glyphs)),
                desc=desc, total=len(self.__glyphs)):
            x_offset = i % horizontal_glyph_count * glyph_width
            y_offset = i // horizontal_glyph_count * glyph_height
            result.paste(image, (x_offset, y_offset))
        return result

    def filename(self):
        return f"font/{self.__provider_type.base_name(self.__classifier)}.png"

    def file_data(self):
        return (self.filename(), self.image())

    def horizontal_glyph_count(self):
        return min(len(self.__glyphs), Provider.__HORIZONTAL_GLYPH_MAX)


class ProviderSet:
    def __init__(self):
        self.__providers_dict: dict[ProviderType, list[Provider]] = dict()

    def add_glyph(self, provider_glyph: ProviderGlyph):
        provider_type = provider_glyph.provider_type()
        if provider_type in self.__providers_dict:
            providers = self.__providers_dict[provider_type]
        else:
            providers = [Provider(provider_type, 0)]
            self.__providers_dict[provider_type] = providers
        provider = providers[-1]
        if not provider.appendable():
            provider = Provider(provider_type, len(providers))
            providers.append(provider)
        provider.append_glyph(provider_glyph)

    def providers(self):
        return list(
                itertools.chain.from_iterable(self.__providers_dict.values()))


class ResourcePack(ZipFile):
    __FONT_INFO_FILENAME = "font-info.json"

    __FONT_INFO_INDENT = 4

    def __init__(self, file: str, compresslevel: int):
        super().__init__(
            file, "w", compression=zipfile.ZIP_DEFLATED,
            compresslevel=compresslevel)
        self.__provider_set = ProviderSet()

    def add_glyph(self, provider_glyph: ProviderGlyph):
        self.__provider_set.add_glyph(provider_glyph)

    def flush(self):
        providers = self.__provider_set.providers()
        self.write_providers(list(
                map(lambda provider: provider.json_object(), providers)))
        file_count = len(providers)
        file_data_iter = map(lambda provider: provider.file_data(), providers)
        file_data_list = list(tqdm(
                file_data_iter, desc="Create image files", total=file_count))
        for filename, image in tqdm(file_data_list, desc="Save image files"):
            self.write_image("assets/minecraft/textures/" + filename, image)
        self.__provider_set = ProviderSet()

    def write_json(self, filename: str, json_object: dict,
                   indent: int | str | None = None):
        with self.open(filename, "w") as json_file:
            json.dump(
                    json_object, TextIOWrapper(json_file, "utf-8"),
                    indent=indent)

    def write_pack_mcmeta(self, pack_format: int, description: str):
        self.write_json("pack.mcmeta", {
            "pack": {
                "pack_format": pack_format,
                "description": description
            }
        })

    def write_font_info(self, font: Font):
        self.write_json(ResourcePack.__FONT_INFO_FILENAME, {
            "headers": font.headers,
            "props": font.props
        }, ResourcePack.__FONT_INFO_INDENT)

    def write_providers(self, providers: list[dict]):
        self.write_json("assets/minecraft/font/default.json", {
            "providers": providers
        })

    def write_image(self, filename: str, image: Image):
        with self.open(filename, "w") as file:
            image.save(file, "PNG")


def div_round_up(a: int, b: int):
    return (a + b - 1) // b
